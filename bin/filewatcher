#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/filewatcher'
require_relative '../lib/filewatcher/env'
require_relative '../lib/filewatcher/runner'
require_relative '../lib/filewatcher/version'

require 'clamp'

class Filewatcher
  ## Class for CLI
  class CLI < Clamp::Command
    banner <<~TEXT
      Filewatcher scans the file system and executes shell commands when files changes.
    TEXT

    option %w[-I --immediate], :flag, 'immediately execute a command',
      default: false

    option %w[-E --every], :flag, 'run command for every updated file in one file system check',
      default: false

    option %w[-D --daemon], :flag, 'run in the background as system daemon',
      default: false

    option %w[-r --restart], :flag, 'restart process when file system is updated',
      default: false

    option '--restart-signal', 'VALUE', 'termination signal for `restart` option',
      default: 'TERM'

    option '--list', :flag, 'print name of files being watched',
      default: false

    option %w[-e --exec], :flag, 'execute file as a script when file is updated',
      default: false

    option '--include', 'GLOB', 'include files',
      default: File.join('**', '*')

    option '--exclude', 'GLOB', 'exclude file(s) matching', default: nil do |string|
      split_files_void_escaped_whitespace string.split(' ') unless string.to_s.empty?
    end

    option %w[-i --interval], 'SECONDS', 'interval to scan file system', default: 0.5 do |string|
      Float(string)
    end

    option %w[-s --spinner], :flag, 'show an ASCII spinner',
      default: false

    parameter 'FILES', 'file names to scan'

    parameter '[COMMAND]', 'shell command to execute when file changes'

    def execute
      @child_pid = nil

      initialize_filewatcher

      print_if_list

      Process.daemon(true, true) if daemon?

      @filewatcher.watch do |changes|
        changes = every? ? changes : changes.first(1)

        process_changes changes
      end
    rescue SystemExit, Interrupt
      @filewatcher.finalize
    end

    private

    def initialize_filewatcher
      ## https://github.com/mdub/clamp/issues/105
      @filewatcher = Filewatcher.new(
        files,
        immediate: immediate?, every: every?, daemon: daemon?,
        restart: restart?, restart_signal: restart_signal, list: list?, exec: exec?,
        include: include, exclude: exclude, interval: interval, spinner: spinner?
      )
    end

    def split_files_void_escaped_whitespace(files)
      files
        .map { |name| name.gsub(/\\\s/, '_ESCAPED_WHITESPACE_').split(/\s/) }
        .flatten
        .uniq
        .map { |name| name.gsub('_ESCAPED_WHITESPACE_', '\ ') }
    end

    def process_changes(changes)
      changes.each do |filename, event|
        command = command_for_file filename

        next puts "file #{event}: #{filename}" unless command

        @child_pid = execute_command filename, event, command
      end
    end

    def print_if_list
      return unless list?

      puts 'Watching:'
      @filewatcher.found_filenames.each { |filename| puts " #{filename}" }
    end

    def execute_command(filename, event, command)
      env = Filewatcher::Env.new(filename, event).to_h
      if restart?
        restart(@child_pid, restart_signal, env, command)
      else
        spawn env, command
        nil
      end
    end

    def command_for_file(filename)
      if exec? && File.exist?(filename) then Filewatcher::Runner.new(filename).command
      elsif command then command
      end
    end

    def restart(pid, restart_signal, env, command)
      begin
        raise Errno::ESRCH unless pid

        Process.kill(restart_signal, pid)
        Process.wait(pid)
      rescue Errno::ESRCH
        nil # already killed
      end
      Process.spawn(env, command)
    end

    def spawn(env, command)
      Process.spawn(env, command)
      Process.wait
    rescue SystemExit, Interrupt
      exit(0)
    end
  end
end

Filewatcher::CLI.run
